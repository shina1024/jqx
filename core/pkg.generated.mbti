// Generated using `moon info`, DON'T EDIT IT
package "shina1024/jqx/core"

// Values
pub fn eval(Filter, Json) -> Array[Json] raise EvalError

#label_migration(max_nesting_depth, fill=false)
pub fn parse(StringView, max_nesting_depth? : Int) -> Json raise ParseError

pub fn parse_filter(StringView) -> Filter raise FilterError

pub fn valid(StringView) -> Bool

// Errors
pub suberror EvalError {
  TypeError(String)
  UnknownFunction(String)
  UnknownVariable(String)
}
pub impl Eq for EvalError
pub impl Show for EvalError

pub suberror FilterError {
  InvalidChar(Position, Char)
  InvalidEof
  Expected(String, Position)
  InvalidNumber(Position, String)
  UnsupportedLiteral(Position)
}
pub impl Eq for FilterError
pub impl Show for FilterError

pub suberror ParseError {
  InvalidChar(Position, Char)
  InvalidEof
  DepthLimitExceeded
}
pub impl Eq for ParseError
pub impl Show for ParseError

// Types and methods
pub enum Filter {
  Identity
  Pipe(Filter, Filter)
  Comma(Filter, Filter)
  Field(String)
  FieldOpt(String)
  Index(Int)
  IndexOpt(Int)
  Iter
  IterOpt
  Literal(Json)
  Array(Array[Filter])
  Object(Array[(String, Filter)])
  Builtin(String)
  Call(String, Array[Filter])
  Var(String)
  As(Filter, String, Filter)
  Try(Filter)
  TryCatch(Filter, Filter)
  Eq(Filter, Filter)
  Neq(Filter, Filter)
  Lt(Filter, Filter)
  Lte(Filter, Filter)
  Gt(Filter, Filter)
  Gte(Filter, Filter)
  And(Filter, Filter)
  Or(Filter, Filter)
  Not(Filter)
  Add(Filter, Filter)
  Sub(Filter, Filter)
  Mul(Filter, Filter)
  Div(Filter, Filter)
  IfElse(Filter, Filter, Filter)
  Fallback(Filter, Filter)
  Empty
}
pub fn Filter::add(Self, Self) -> Self
pub fn Filter::and_(Self, Self) -> Self
pub fn Filter::as_(Self, String, Self) -> Self
pub fn Filter::builtin(String) -> Self
pub fn Filter::call(String, Array[Self]) -> Self
pub fn Filter::comma(Self, Self) -> Self
pub fn Filter::div(Self, Self) -> Self
pub fn Filter::empty() -> Self
pub fn Filter::eq(Self, Self) -> Self
pub fn Filter::fallback(Self, Self) -> Self
pub fn Filter::field(String) -> Self
pub fn Filter::field_opt(String) -> Self
pub fn Filter::gt(Self, Self) -> Self
pub fn Filter::gte(Self, Self) -> Self
pub fn Filter::identity() -> Self
pub fn Filter::if_else(Self, Self, Self) -> Self
pub fn Filter::index(Int) -> Self
pub fn Filter::index_opt(Int) -> Self
pub fn Filter::iter() -> Self
pub fn Filter::iter_opt() -> Self
pub fn Filter::literal(Json) -> Self
pub fn Filter::lt(Self, Self) -> Self
pub fn Filter::lte(Self, Self) -> Self
pub fn Filter::mul(Self, Self) -> Self
pub fn Filter::neq(Self, Self) -> Self
pub fn Filter::not(Self) -> Self
pub fn Filter::or_(Self, Self) -> Self
pub fn Filter::pipe(Self, Self) -> Self
pub fn Filter::sub(Self, Self) -> Self
pub fn Filter::try_(Self) -> Self
pub fn Filter::try_catch(Self, Self) -> Self
pub fn Filter::var_(String) -> Self
pub impl Eq for Filter
pub impl Show for Filter

pub enum Json {
  JNull
  JTrue
  JFalse
  Number(Double, String?)
  String(String)
  Array(Array[Json])
  Object(Map[String, Json])
}
pub fn Json::array(Array[Self]) -> Self
pub fn Json::boolean(Bool) -> Self
pub fn Json::null() -> Self
pub fn Json::number(Double, repr? : String) -> Self
pub fn Json::object(Map[String, Self]) -> Self
pub fn Json::string(String) -> Self
pub fn Json::to_json_string(Self) -> String
pub impl Eq for Json
pub impl Show for Json

pub struct Position {
  line : Int
  column : Int
}
pub impl Eq for Position

// Type aliases

// Traits

