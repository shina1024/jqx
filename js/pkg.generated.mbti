// Generated using `moon info`, DON'T EDIT IT
package "shina1024/jqx/js"

import {
  "shina1024/jqx/core",
}

// Values
pub fn add(Query[@core.Json, @core.Json], Query[@core.Json, @core.Json]) -> Query[@core.Json, @core.Json]

pub fn call(String, Array[Query[@core.Json, @core.Json]]) -> Query[@core.Json, @core.Json]

pub fn comma(Query[@core.Json, @core.Json], Query[@core.Json, @core.Json]) -> Query[@core.Json, @core.Json]

pub fn compile(String) -> @core.Filter raise @core.FilterError

pub fn eq(Query[@core.Json, @core.Json], Query[@core.Json, @core.Json]) -> Query[@core.Json, @core.Json]

pub fn execute(@core.Filter, @core.Json) -> Array[@core.Json] raise @core.EvalError

pub fn executeQuery(Query[@core.Json, @core.Json], @core.Json) -> Result[Array[@core.Json], String]

pub fn executeToJsonStrings(String, String) -> Result[Array[String], String]

pub fn fallback(Query[@core.Json, @core.Json], Query[@core.Json, @core.Json]) -> Query[@core.Json, @core.Json]

pub fn field(String) -> Query[@core.Json, @core.Json]

pub fn identity() -> Query[@core.Json, @core.Json]

pub fn index(Int) -> Query[@core.Json, @core.Json]

pub fn iter() -> Query[@core.Json, @core.Json]

pub fn literal(@core.Json) -> Query[@core.Json, @core.Json]

pub fn map(Query[@core.Json, @core.Json]) -> Query[@core.Json, @core.Json]

pub fn parseFilter(String) -> @core.Filter raise @core.FilterError

pub fn parseJson(String) -> @core.Json raise @core.ParseError

pub fn pipe(Query[@core.Json, @core.Json], Query[@core.Json, @core.Json]) -> Query[@core.Json, @core.Json]

pub fn run(String, String) -> Result[Array[String], String]

pub fn runCompat(String, String) -> Result[Array[String], String]

pub fn runQuery(Query[@core.Json, @core.Json], String) -> Result[Array[String], String]

pub fn runValues(String, String) -> Result[Array[@core.Json], String]

pub fn safeCompile(String) -> Result[@core.Filter, String]

pub fn safeExecute(@core.Filter, @core.Json) -> Result[Array[@core.Json], String]

pub fn safeParseFilter(String) -> Result[@core.Filter, String]

pub fn safeParseJson(String) -> Result[@core.Json, String]

pub fn safeRunValues(String, String) -> Result[Array[@core.Json], String]

pub fn select(Query[@core.Json, @core.Json]) -> Query[@core.Json, @core.Json]

pub fn tryCompile(String) -> Result[@core.Filter, String]

pub fn tryExecute(@core.Filter, @core.Json) -> Result[Array[@core.Json], String]

pub fn tryParseFilter(String) -> Result[@core.Filter, String]

pub fn tryParseJson(String) -> Result[@core.Json, String]

pub fn try_catch(Query[@core.Json, @core.Json], Query[@core.Json, @core.Json]) -> Query[@core.Json, @core.Json]

// Errors

// Types and methods
pub struct Query[I, O] {
  filter : @core.Filter
  _input : I?
  _output : O?
}
pub fn[I, O] Query::toFilter(Self[I, O]) -> @core.Filter

// Type aliases

// Traits

